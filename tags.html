---
layout: default
title: タグ一覧
---

<main class="main-content container">
  {% raw %}
  <div id="app" v-cloak>
    <div class="field">
      <p class="control has-icons-left" :class="{ 'is-loading': loading }">
        <input
          class="input"
          type="text"
          placeholder="Search"
          v-model="searchText"
          @input="search"
        />
        <span class="icon is-small is-left">
          <i class="fas fa-search"></i>
        </span>
      </p>
    </div>

    <nav class="panel" v-for="tag in filtered" v-if="!loading" :key="tag.tag">
      <p class="panel-heading">
        <span class="icon">
          <i class="fas fa-tag"></i>
        </span>
        {{ tag.tag }} ({{ tag.posts.length }})
      </p>
      <a
        class="panel-block"
        v-for="post in tag.posts"
        :key="post.url"
        :href="post.url"
      >
        <span class="panel-icon">
          <i class="fas fa-angle-right" aria-hidden="true"></i>
        </span>
        {{ post.title }}
      </a>
    </nav>
  </div>
  {% endraw %}
</main>
<script>
  new Vue({
    el: '#app',
    computed: {
      loading: function() {
        return this.postsLoading || this.tagsLoading;
      }
    },
    data: function() {
      return {
        tagsLoading: false,
        postsLoading: false,
        searchText: '',
        tags: [],
        posts: [],
        tagSet: [],
        filtered: []
      };
    },
    mounted: function() {
      var query = window.location.search;
      if (query) {
        var tag = query
          .slice(1)
          .split('&')
          .map(function(e) {
            return e.split('=');
          })
          .find(function(e) {
            return e[0] === 'tag';
          });
        if (tag) {
          this.searchText = tag[1];
        }
      }
      var self = this;
      self.tagsLoading = true;
      axios
        .get("{{ '/tags.json' | relative_url }}")
        .then(function(res) {
          self.tags = res.data;
          self.setTagSet();
          self.filterPosts();
        })
        .finally(function() {
          self.tagsLoading = false;
        });
      self.postsLoading = true;
      axios
        .get("{{ '/index.json' | relative_url }}")
        .then(function(res) {
          self.posts = res.data;
          self.setTagSet();
          self.filterPosts();
        })
        .finally(function() {
          self.postsLoading = false;
        });
    },
    methods: {
      setTagSet: function() {
        if (this.posts.length === 0 || this.tags.length === 0) {
          return;
        }
        var ps = this.posts;
        this.tagSet = this.tags.map(function(tag) {
          return {
            tag: tag,
            posts: ps.filter(function(post) {
              return post.tags.includes(tag);
            })
          };
        });
      },
      filterPosts: function() {
        if (this.posts.length === 0 || this.tags.length === 0) {
          return;
        }
        var txt = this.searchText;
        if (!txt) {
          this.filtered = [].concat(this.tagSet);
          return;
        }
        this.filtered.splice(0);
        var self = this;
        this.tagSet.forEach(function(tag) {
          if (tag.tag.includes(txt)) {
            self.filtered.push(tag);
            return;
          }
          var ps = tag.posts.filter(function(post) {
            return post.title.includes(txt);
          });
          if (ps.length) {
            self.filtered.push({
              tag: tag.tag,
              posts: ps
            });
          }
        });
      },
      search: function(e) {
        this.searchText = e.target.value;
        this.filterPosts();
      }
    }
  });
</script>
